= リモートキャッシュ
:experimental:


=== Hot Rod クライアント
Hot Rod は、Infinispan が高性能なクライアント・サーバー間インタラクションのために提供するバイナリ TCP プロトコルであり、以下の機能を持ちます。:

* *ロードバランシング*: Hot Rod クライアントは、信頼性を向上させるために、様々な戦略を使って Infinispan クラスタ間でリクエストを送信できます。
* *フェイルオーバー*: Hot Rod クライアントは、Infinispan クラスタのトポロジーの変更を監視し、利用可能なノードに自動的に切り替えることができます。
* *効率的なデータ配置*: Hot Rod クライアントは key オーナーを見つけ、key オーナーを持つノードに直接リクエストを送信し、待ち時間を短縮することができます。


=== リモートキャッシュ
`RemoteCache` はその名の通り、リモートからアクセスできるキャッシュです。Data Grid サーバーはこのリモートキャッシュをホストし、クライアントはこのリモートキャッシュに接続します。
設計の観点から、より柔軟性があり、複数のキャッシュが存在するセントラル・デプロイメントを持つことができます。

Infinispan/Red Hat Data Grid の `RemoteCache` と `EmbeddedCache` の公開方法には違いがあります。
コレクションメソッド `keySet()`, `entrySet()`, `values()` はリモートキャッシュによってバックアップされます。
呼び出されたメソッドはすべて `RemoteCache` に送り返されます。
これは、様々なキーやエントリや値を遅延して取得することができ、ユーザが望まない場合にはそれらを一度にクライアントのメモリに保存する必要がないので便利です。

これらのコレクションは `Map` の仕様に準拠しており、`add()` と `addAll()` はサポートされていませんが、その他のメソッドはすべてサポートされています。
注意点としては、 `Iterator.remove()`、`Set.remove()`、`Collection.remove()` メソッドを使用する際には、サーバーとのラウンドトリップを複数回行う必要があるということです。
これらのメソッドやその他のメソッドの詳細については、 `RemoteCache` https://access.redhat.com/webassets/avalon/d/red-hat-data-grid/8.4/api/org/infinispan/client/hotrod/RemoteCache.html[Javadoc] を参照してください。


=== プロジェクト詳細
この例では、簡単なウェブ・アプリケーションを作成します。ウェブフォームからいくつかの入力を受け取り、エントリーをキャッシュに追加します。
しかし、今回は ProtoStream API を使って `RemoteCacheManager` を使用し、すべて Quarkus ベースのアプリケーションにて実装します。

早速始めましょう。まずはプロジェクトを見てみましょう。

{{ CHE_URL }}[CodeReady Workspaces^] に戻り、プロジェクト `dg8-quarkus-client-example` に移動します。これはテンプレートプロジェクトであり、この中にコードを記述します。
既にいくつかのファイルが用意されています。これらのファイルが何であり、何をしているのかを見てみましょう。


=== Maven 依存関係
プロジェクト内の `pom.xml` を開きます。

以下の依存関係を使用してサービスを作成します。

[source, xml]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy</artifactId> <1>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-jsonb</artifactId> <2> 
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-infinispan-client</artifactId> <3>
    </dependency>
    <dependency>
----

<1> `quarkus-resteasy` : REST エンドポイント
<2> `quarkus-resteasy-jsonb` : REST エンドポイントのための JSON シリアライゼーション
<3> `quarkus-infinispan-client` : Data Grid の `RemoteCache` の使用の有効化


=== Protobuf
Protobuf またはプロトコルバッファは、構造化データをシリアライズする方法です。
プロトコルバッファは、構造化データをシリアライズするための柔軟で効率的、かつ自動化されたメカニズムです。
様々なデータストリームに、様々な言語を使って、簡単にデータを書き込んだり読み込んだりすることができます。
Protobuf は構造化データがすべてなので、最初に行うことは構造を定義することです。
これは、`.proto` ファイルで Protobuf メッセージタイプを宣言することで実現できます。

この例では `game.proto`ファイルは次のようになっています。:

[source, protobuf, role="copypaste"]
----
package quickstart; <1> 

message Game { <2>
    required string name = 2; <3>
    required string description = 3; <4>
}
----

<1> メッセージのパッケージを定義します。
<2> メッセージの名前を定義します。メッセージはエンティティに似ています。
<3> メッセージが `name` という文字列であり、必須であることを指定します。
<4> メッセージは `description` という文字列であり、必須であることを指定します。

上記の内容を次のファイルに保存します。: src/main/resources/META-INF/game.proto`


=== マーシャラー
前のセクションで説明したように、Protobuf フォーマットの基本的な概念は、`.proto` スキーマでメッセージを定義し、エンティティの表現方法を決定することです。
しかし、Java アプリケーションにおいて Protobuf フォーマットを利用してデータを送信/保存するには、Javaオブジェクトをエンコードする必要があります。
これは、ProtoStream ライブラリと設定された Marshaller 実装によって処理され、POJO (plain old Java objects) を Protobuf 形式に変換します。

リソースの生成は ProtoStream を利用する最も簡単でパフォーマンスの高い方法ですが、この方法が常に実行できるとは限りません。
例えば、Java オブジェクト・クラスを変更して必要なアノテーションを追加できない場合などです。
このような使用例では、手動で `.proto` スキーマを定義して、手動マーシャラー実装を作成することができます。
マーシャラーを定義してみましょう。

`dg8-quarkus-client-example/src/main/java/org/acme/rest/json` フォルダにある `GameMarshaller` クラスを開きます。

以下のメソッドを `GameMarshaller` クラスに追加します。
以下のコードでは ProtoStream から *読み込む* 方法を指定しています。
必要であれば、ストリームに追加処理を加えることもできます。
単純な読み込みを行い、`Game` オブジェクトを返すことにします。
従って、ストリームが Cache から読み込まれるたびに、このメソッドが呼び出されることになります。

[source, java, role="copypaste"]
----
    @Override
    public Game readFrom(MessageMarshaller.ProtoStreamReader reader) throws IOException {
        String name = reader.readString("name");
        String description = reader.readString("description");
        return new Game(name, description);
    }
----

次に、*書き込み* メソッドも定義します。このメソッドは Game オブジェクトを受け取り、それをストリームに変換します。

[source, java, role="copypaste"]
----
    @Override
    public void writeTo(MessageMarshaller.ProtoStreamWriter writer, Game game) throws IOException {
        writer.writeString("name", game.getName());
        writer.writeString("description", game.getDescription());
    }
----

Stream データを扱うクラスを指定しましょう。

[source, java, role="copypaste"]
----
    @Override
    public Class<? extends Game> getJavaClass() {
        return Game.class;
    }
----

そして最後に、シリアライゼーションプロセスに、どの Proto タイプに対してこの処理を行うのか、すなわち packagename.Class を知らせます。:

[source, java, role="copypaste"]
----
    @Override
    public String getTypeName() {
        return "quickstart.Game";
    }
----

これでマーシャラーの設定ができました。


=== RemoteCache の設定
続いて RemoteCache の設定を作成しましょう。

`Init.java` を開いて、以下のメンバ変数を追加します。

[source, java, role="copypaste"]
----
    public static final String GAME_CACHE = "games"; <1>

    @Inject
    RemoteCacheManager cacheManager; <2> 

    private static final String CACHE_CONFIG = "<distributed-cache name=\"%s\">" <3>
          + " <encoding media-type=\"application/x-protostream\"/>" <4>
          + "</distributed-cache>";
----

<1> 初めにクラスレベルの変数にキャッシュの名前を指定します。
<2> `cacheManager` をインジェクトします。`CacheManager` は重いオブジェクトであり、起動時のみにロードします。
<3> コード内でキャッシュを設定するだけでなく、XML を使ってキャッシュを設定することもできます。`META-INF`ディレクトリにあるファイルから読み込むこともできますが、短いデモの場合はこの方法でも問題ありません。
<4> キャッシュのエンコーディングは、Protobuf でエンコードされたデータをキャッシュに格納し、最高の相互運用性とクエリサポートを得るために Protostream を使用しています。

[source, java, role="copypaste"]
----
    void onStart(@Observes @Priority(value = 1) StartupEvent ev) {
        String xml = String.format(CACHE_CONFIG, "games"); <1>
        cacheManager.administration().getOrCreateCache(GAME_CACHE, new XMLStringConfiguration(xml)); <2>
    }
----

`onStart()` メソッドは以前の演習で使ったので覚えているかもしれません。ここでも同じことをしています。
<1> `String` で定義した XML を Red Hat Data Grid サーバに渡して解析してもらい、`games` という新しいキャッシュを作成します。
<2> 次に `cacheManager` からキャッシュを取得するか、キャッシュが存在しない場合は新規作成するように依頼します。

これで `RemoteCacheManager` が設定されたはずですので、あとは REST リソースからこれを使うだけです。


=== REST エンドポイント
`GameResource.java` を開いてください、このクラスは JAX-RS を使ってアプリケーションの REST リソースを定義しています。

次のコードでは、`RemoteCache` をインジェクトし、`Init` クラスにて初期化した `GAME_CACHE` 変数を渡して、どのリモートキャッシュを使用するかを指定しています。

以下のコードを `GameResource.java` に追加します。

[source, java, role="copypaste"]
----
    @Inject
    @Remote(GAME_CACHE)
    RemoteCache<String, Game> gameStore;
----


以下は2つの単純な GET メソッドと POST メソッドの実装です。:

[source, java, role="copypaste"]
----
    @GET
    public Set<Game> list() {
        return new HashSet<>(gameStore.values());
    }

    @POST
    public Set<String> add(Game game) {
        gameStore.putAsync(game.getName(), game);
        return gameStore.keySet();
    }
----

<1> `list` メソッドは単純にゲームをフロントエンドに返しています。
<2> `add` メソッドは Infinispan/Red Hat Data Grid の非同期 API を使用して、エントリをキャッシュに追加しています。

アプリケーションを Openshift にデプロイして、`RemoteCache` がどのように機能するかを確認する準備ができました。


=== Openshift へのデプロイとスケーリング
Openshift にアプリケーションをデプロイする準備をしましょう。

`src/main/resources/application.properties` を開いてください。

[source, properties, role="copypaste"]
----
%prod.quarkus.infinispan-client.server-list=datagrid-service:11222 <1>

# Auth. Set use-auth to false to connect to a non-authenticated Data Grid
%prod.quarkus.infinispan-client.use-auth=true<2>
%prod.quarkus.infinispan-client.auth-username=developer<3>
%prod.quarkus.infinispan-client.auth-password=bvTxphbrUvmkorxu<4>

# SSL configuration. Remove these properties if you disable SSL
%prod.quarkus.infinispan-client.trust-store=/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt<5>
%prod.quarkus.infinispan-client.trust-store-type=pem<6>


quarkus.http.cors=true

# Openshift extension settings.
quarkus.openshift.expose=true 

# if you dont set this and dont have a valid cert the deployment wont happen

quarkus.kubernetes-client.trust-certs=true
quarkus.container-image.build=true
quarkus.kubernetes.deploy=true
quarkus.infinispan-client.devservices.enabled=false

----

<1> 接続先の Infinispan ホスト名/ポートを設定します。複数指定する場合にはセミコロンで区切ります（例：host1:11222;host2:11222）。
<2> 認証が有効であることを示します。
<3> 認証に使用するユーザ名を設定します。ここでは `developer` とします。
<4> 認証に使用するパスワードを設定します。Secrets から見つけ出します。
<5> 証明書のトラストストアです。
<6> 最後にトラストストアのタイプを指定します。

上記のプロパティファイルのパスワードフィールドを埋めましょう。

ターミナルにて以下のコマンドを実行すると、パスワードが表示されます。`developer` ユーザーのパスワードをコピーして、パスワードフィールド `quarkus.infinispan-client.auth-password=` に追加します。

[source, shell, role="copypaste"]
----
oc get secret datagrid-service-generated-secret -o jsonpath="{.data.identities\.yaml}" | base64 --decode
----

アプリケーションを OpenShift にデプロイしてみましょう。

[source, shell, role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/dg8-workshop-labs/dg8-quarkus-client-example
----

ビルドが成功するのを待ちましょう。通常であれば、アプリをビルドし、コンテナをビルドし、YAMLファイルを作成するためにすべてのコマンドを実行する必要があります。Quarkus Openshift エクステンションは、maven プラグインを経由して、今回行ったようなシンプルな1行コマンドでこれを行います。

{{ CONSOLE_URL }}[OpenShift web console^] に移動し、トポロジービューへ切り替えます。

image::gameserviceocp.png[cdw, 700, align="center"]

`dg8-quarkus-client-example`アプリケーションを見つけて、Route をクリックしてアプリケーションに移動します。

image::gameserviceocproute.png[cdw, 700, align="center"]

アプリケーションは別のタブで開き、以下のようなインターフェイスを表示します。ウェブフォームを使ってキーとバリューのペアを保存することができます。その後、自動的に以下のキャッシュの内容が表示されます。

image::gamerestservice.png[cdw, 700, align="center"]

アプリケーションをいじってみたり、ゲームを追加してみたりしてみてください。また、アプリケーションや Data Grid Pod をいくつか削除してみて、動作を確認してみてください。


=== ニアキャッシュの有効化
ニアキャッシュは Hot Rod Java クライアント実装のオプションのキャッシュで、最近アクセスされたデータをユーザーの近くに保持し、頻繁にアクセスされるデータへの高速アクセスを提供します。
このキャッシュはローカルの Hot Rod クライアントキャッシュとして動作し、リモートエントリが `get` または `getVersioned` オペレーションで取得されるたびに更新されます。

Red Hat Data Grid では、エントリが変更または削除されたときにクライアントに通知を送信するリモートイベントを使用することで、ニアキャッシュ一貫性を実現します (リモートイベントリスナーを参照)。
ニアキャッシュでは、ローカルキャッシュはリモートキャッシュと一貫性を保ちます。
サーバー上のリモートエントリが更新または削除されるたびに、ローカルエントリは更新または無効化されます。クライアントレベルでは、ニア・キャッシュは以下のいずれかとして構成可能です。:

- *DISABLED* - ニアキャッシュが有効になっていないことを示すデフォルトモード。
- *INVALIDATED* - ニアキャッシュを有効にし、無効化メッセージによってリモートキャッシュとの同期を保つ。

image::nearcache.png[Near Caching, 700]

==== いつ使うべきか？
あるキャッシュへのアクセスのほとんどが読み取り専用で、アクセスされるデータセットが比較的小さい場合、ニアキャッシュはアプリケーションのパフォーマンスを向上させることができます。
キャッシュへの書き込みが多いアプリケーションでは、ニアキャッシュへの無効化・Eviction・更新が必要になります。
このようなシナリオでは、ニアキャッシュが提供するメリットは必ずしも有益ではありません。

Quarkus では、ニアキャッシュはデフォルトで無効になっています。プロファイル設定のプロパティ `quarkus.infinispan-client.near-cache-max-entries` を `0` より大きい値に設定することで、ニアキャッシュを有効にすることができます。
また、正規表現を設定して、`quarkus.infinispan-client.near-cache-name-pattern` プロパティでキャッシュのサブセットのみにニアキャッシュを適用させることもできます。

以下のプロパティを `application.properties` に追加して、ニアキャッシュを有効化します。

[source, properties, role="copypaste"]
----
quarkus.infinispan-client.cache.games.near-cache-mode=INVALIDATED 
quarkus.infinispan-client.cache.games.near-cache-max-entries=40 
----

WARNING: コンパイル時または実行時において、`Unrecognized configuration key "quarkus.infinispan-client.cache.games.near-cache-mode" was provided` のような WARN が表示された場合、`pom.xml` を開き、`quarkus.platform.version` を `2.15.3.Final` にアップグレードしてください。

アプリケーションを OpenShift に再デプロイしてみましょう。

[source, shell, role="copypaste"]
----
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/dg8-workshop-labs/dg8-quarkus-client-example
----

この実行でも Build Successful のメッセージが表示されるはずです。

このデプロイの前にキャッシュに追加されたかもしれないすべてのエントリが残っている可能性があることに注意してください。
エンベデッドキャッシュでは、ストアを使用しておらず、アプリケーションが起動するたびにキャッシュが空になるため、そのようなことはありませんでした。
今回のケースでは、キャッシュはリモートなので、前回のエントリが残っています。
ャッシュの設定とセットアップにはさまざまな方法があることに注意することが重要です。詳細は Red Hat Data Grid のドキュメントページを参照してください。


=== Hibernate/JPA と Quarkus によるキャッシング
Quarkus にて Hibernate ORM を使用する場合、設定用の `persistence.xml` ファイルは必要ありません。
このような古典的な設定ファイルを使用することはオプションですが、特別な高度なニーズがない限り不要です。
Hibernate ORM を persistence.xml リソースなしでどのように設定できるかを見てみましょう。

Quarkus では以下の作業を実施する必要があります。:

- コンフィギュレーション設定を `application.properties` に追加します。
- 通常通り `@Entity` とその他のマッピングアノテーションでエンティティにアノテーションを付けます。

その他の設定は自動化されています。: Quarkus ではいくつかの拘った選択と経験則に基づいた推測を行います。

[source, java, role="copypaste"]
----
package org.acme;

@Entity
@Cacheable
public class Country {
    // ...

    @OneToMany
    @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
    List<City> cities;

    // ...
}
----

上記のコードでは、`@Cacheable` アノテーションを使用するだけで、Infinispan がエンティティの第2レベルキャッシュとして使用されるようになります。また、実装を選ぶ必要もありません。
Infinispan の技術に基づいた適切な実装は、Hibernate ORM 拡張機能の推移的依存関係として含まれており、ビルド中に自動的に統合されます。


=== まとめ
. `RemoteCache` と HotRod クライアントについて学びました。
. Infinispan の Protostream とマーシャラーについて学びました。
. `RemoteCache` を使用して Quarkus アプリを OpenShift にデプロイしました。
. ニアキャッシュとその使用例について学びました。
. 最後に、JPAとセカンドレベルキャッシュについてまとめました。

リモートキャッシュに関する演習は完了しました。次の演習へ移りましょう。
