= Red Hat Data Grid とは
:experimental:

Red Hat Data Grid とは、分散型インメモリ、NoSQL データストア・ソリューションです。
アプリケーションは、インメモリ速度でデータにアクセス・処理・分析することができるようになります。
レガシーアプリケーションを使用する場合でも、新しいマイクロサービスや機能を使用する場合でも、Red Hat Data Grid 8 はオープン・ハイブリッド・クラウドへの移行を可能にします。
Red Hat Data Grid には Infinispan オープンソース・ソフトウェア・プロジェクトが含まれています。
組み込みライブラリ、スタンドアロンサーバー、または Red Hat OpenShift Container Platform 上のコンテナアプリケーションとしてデプロイできます。

image::dg8.png[Red Hat Data Grid 8.2, 700]

=== Operator による完全なライフサイクル管理
Operator は、Kubernetes API を使用して、アプリケーションの運用とライフサイクル管理を自動化します。
これは、複雑なアプリケーション（例えば、分散キャッシュ、データベースなど）が、新しいバージョンが到着した場合などに人手を介さずに簡単にアップグレードできることを意味します。
Operator SDK により、開発者はそのような Operator を書くことができます。
Red Hat Data Grid は、運用インテリジェンスを提供する完全にサポートされた Data Grid Operator を用いてインストールされます。

=== 新しいサーバーアーキテクチャ
クラウドとコンテナネイティブの Data Grid はフットプリントを削減する必要があり、Red Hat Data Grid の最新バージョンにおいて実現されています。
ディスクフットプリントと初期ヒープサイズの両方を最大 50% 削減し、キャッシュデータを格納するために多くのメモリを残します。
Red Hat JBoss Enterprise Application Platform (EAP) なしでサーバーを実行できるようになったため、メモリとディスクのフットプリントが小さくなり、構成もシンプルになりました。

さらに、Red Hat Data Grid 8 サーバーは、Red Hat SSO との統合や攻撃対象領域の縮小など、セキュリティに関するいくつかの機能強化や改善を提供しています。

=== 高性能で豊富な REST API
Red Hat Data Grid 8 は REST API v2 を導入しています。
この API は v1 と比較してレスポンス速度が 50% 高速化されています。 また、以下のような新しい機能も導入されています。：

* データへのアクセスとオブジェクト（カウンターなど）の操作
* Data Grid クラスタを安全にシャットダウンしたり、クロスサイトレプリケーションを使用している時にキャッシュの状態をバックアップ・ロケーションに転送したりするような操作の実行
* クラスタとサーバの健全性を監視し、統計情報の取得

さらに、Red Hat Data Grid REST API v2 は、相互運用性を高めるために、JSON・XML・Protobuf・プレーンテキストなどのストレージフォーマット間を自動的に変換します。
Red Hat Data Grid エンジニアリングチームは、包括的な REST API ドキュメントを開発・維持しています。

=== パワフルな CLI
Red Hat Data Grid では、データへのリモートアクセスとクラスタ管理のための CLI が提供されています。
CLIでは `cd` や `ls` といった使い慣れた Bash コマンドを使うことができます。また、コマンドの履歴や自動補完機能も提供されています。

さらに、CLI ではコマンドのヘルプテキストやマニュアルページをわかりやすい例とともに提供しています。

=== 可観測性(オブザーバビリティ)の強化
Prometheus との統合により `/metrics` エンドポイントを利用できます。
さらに、Red Hat Data Grid 8 は Eclipse Microprofile Metrics API と互換性があります。
また、より具体的なメトリクスやゲージも含まれています。
また、Data Grid 8 は JMX 経由での統計・管理操作の改善や、粗い粒度のロギング・カテゴリーと JSON フォーマットのログのサポートの更新も提供しています。


== キャッシングとは何か、Red Hat Data Grid ではどのように適用するのか？
モダンアプリケーションでは、データベース・ファイル・Web サービス・RPC 呼び出しなどから取得されたデータが大量に利用されています。
アプリケーションにてこれらのデータを処理する場合、最も自然な方法は何でしょうか? ほとんどの場合、アプリケーションはこのデータをメモリ内で処理することでしょう。
ネットワーク遅延や大量のデータを返す大きなクエリなど、何らかの理由でデータベースが非常に遅い場合を仮定しましょう。
これを処理する最も簡単な方法は、そのデータの一部をメモリに保存することです。そうすることで、システムへのリクエストをより速く処理できるようになります。ただし、課題もあります。
どれくらいの量のデータをメモリに保存する必要がありますか？そして最も重要なのは、障害が発生した場合に何が起こるかということです。

* メモリ上のデータの状態をすべて失いますか？
* 障害が発生した際と同じ状態に戻るために、すべてのデータやイベントを読み直す必要があるのでしょうか？さもないと、それを完全にメモリ上のデータを失うかもしれません。

上記の2つはとてもシンプルに見えるかもしれませんが、これらの作業は退屈で、最も重要なのはミスを犯しやすいということです。
この時点で、ほとんどの人が過去に使ったことがあるかもしれない、ローカルキャッシュ（例えば `HashMap` ）を導入することを考えるでしょう。
しかし、開発者であれば、障害が発生した際ににあまり効果がないことを知っているかもしれません。
だからこそ、メモリにデータをキャッシュするだけでなく、以下のような機能を持つコンポーネントが必要です。：

1. メモリ上のデータと状態の一貫性
2. 障害発生時の回復力
3. 処理効率とパフォーマンス
4. イベント、ストリーム、配信機能

image::caching.png[Caching, 700]


このような機能により、キャッシュはもはや単なるインメモリ・データ構造ではなくなります。
つまり、開発者としては、このコンポーネントをローカルのインメモリ処理から取り出して、ネットワーク上に分散させることができます。
アプリケーションに障害が発生した場合でも、このデータにアクセスすることができます。

最初の質問に戻ると、メモリにどれだけのデータを保存すべきでしょうか？開発者として重要なのは、キャッシュとそのエントリーに TTL（Time To Live）を指定できるようにすることです。

Eviction と Expiration も定義できるようにする必要があります。
Eviction は、インスタンスのメモリからエントリを削除することによりメモリの過剰使用を防止しますが、キャッシュからエントリを削除しないため他のインスタンスの永続性には影響しません。一貫性を保つために、構成された永続性を使用する必要があります。
一方、Expiration ではエントリは廃止され、キャッシュとその永続性から完全に削除されます。
これにより、キャッシュがいつ使われているか、キャッシュ内にどのようなデータが存在するかを知ることができます。
さらに、これを分散環境・クラスタ全体・またはリモートで実行できる必要があります。

キャッシュがリモートにある場合、例えばモニタリングのような分散機能も欲しくなります。キャッシュ戦略のいくつかを見てみましょう。

==== ローカルキャッシュ
Red Hat Data Grid の主な用途は、頻繁にアクセスされるデータの高速なインメモリキャッシュを提供することです。
低速なデータソース (データベース、Web サービス、テキストファイルなど) があるとします。Red Hat Data Grid を使うことは、単純な `ConcurrentHashMap` を使うよりも優れています。
組み込みキャッシュを設定することで、Red Hat Dat Grid はより多くの機能を利用できるようになります。これらによって、キャッシュとコンポーネントの設計をより良く扱うことができます。さらに、このようなキャッシュをクラスタ化したい場合、それも簡単に可能です。

==== クラスタ化されたキャッシュ
アプリケーションにおいてローカルまたは組み込みキャッシュを利用し始めましたが、アプリケーションの1つのインスタンスではユーザーやシステムからの負荷を処理しきれないことに気づいた場合、どのように対応しますか？
Red Hat Data Grid を使えば、キャッシュをクラスタに拡張することができます。

キャッシュの使い方を変える必要はありません。いくつかのパラメータを追加するだけで、複数のアプリケーションにて利用できるクラスタ化されたキャッシュを持つことができます。

イベントはクラスタ全体で発生し、Expiration はクラスタ全体で発生します。Eviction はローカルメモリからエントリを削除しますが、永続キャッシュストアや他のクラスタメンバーからは削除しません。
さらに、クラスター全体でキーを分散させることもできます。Red Hat Data Grid は水平方向に数百ノードまで拡張できます。

==== リモートキャッシュ
クラスタ化されたキャッシュを使い、それをアプリケーションに組み込んだとしましょう。そうすれば、アプリケーションの新しいインスタンスが起動するたびに、組み込みキャッシュの新しいインスタンスがクラスタの一部になることができます。

これは素晴らしいことです。しかし、アプリケーションにクラスタリングを使いたくないとしたらどうでしょうか？アプリケーションのライフサイクル外のコンポーネントを使いたいかもしれません。
あるいは、このキャッシュを複数のアプリケーションで共有したいかもしれません。その場合、Red Hat Data Grid はリモートデータグリッドとして機能します。

複数のプログラミングランタイム（Vert.x、Quarkus、NodeJS、C#、C/C++など）からキャッシュにアクセスできるようになり、キャッシュのライフサイクルとメモリ消費量はアプリケーションのライフサイクルから独立することができます。

ここまでで、キャッシュの様々なパターンと要件を理解することができました。早速最初のアプリケーションを作成し、Red Hat Data Grid を使ってキャッシュを実現する方法を学びましょう。次へ進んでください。
 
=== 参考資料:
- Traditional zip deployments are available on the link:https://access.redhat.com[Customer Portal, window=_blank] link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?downloadType=distributions&product=data.grid[Red Hat Data Grid download page, window=_blank].
- The container distribution and operator are available in the link:https://catalog.redhat.com/software/containers/explore[Red Hat Container Catalog, window=_blank]
- Product documentation is available link:https://docs.redhat.com[here, window=_blank]
- Getting Started Guide that will get you running with RHDG 8 in 5 minutes.
- link:https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.2/html/migrating_to_data_grid_8/index[Migration Guide, window=_blank] 
- link:https://github.com/redhat-developer/redhat-datagrid-tutorials[Starter Tutorials, window=_blank]
- link:https://access.redhat.com/articles/4933371[Supported Components, window=_blank]
- link:https://access.redhat.com/articles/4933551[Supported Configurations, window=_blank]

