= 基本機能
:experimental:

Red Hat Data Grid の基本的な機能のいくつかを掘り下げていきましょう。
本ワークショップでは、この先さらに掘り下げた内容も多く含まれますが、Red Hat Data Grid と Infinispan についてより深く理解するためには、しっかりとした基礎を固めることが不可欠です。
このセクションでは、3つの演習問題を用意しました。これらの演習では、Red Hat Data Grid Java API の一部の機能の基本的な内容を紹介します。

== ワークショップの開発環境の説明

本ワークショップでは、開発環境として https://www.eclipse.org/che/[Eclipe Che, window=_blank] ベースのオンライン IDE である Red Hat OpenShift Dev Spaces を利用します。Red Hat OpenShift Dev Spaces には以下の特徴があります。:

* CLI ツールをラップトップにインストールする必要はありません。
* 参加者全員が同じツールのバージョンと設定を持つことができます。
* *すべてのファイルの変更は数秒ごとに自動保存されます* ので、変更を明示的に保存する必要はありません。

{{ CHE_URL }}[OpenShift Dev Spaces へアクセス^] し、アサインされたユーザー名・パスワード (e.g. `{{ USER_ID }}/{{ CHE_USER_PASSWORD }}`) を用いてログインしてください。:

image::codeready-login.png[codeready-login, 700, align="center"]

OpenShift Dev Spaces にログインすると、開発ワークスペースにアクセスできます。ワークスペースはすでに作成されています。左メニューのワークスペースをクリックすると開発環境を開くことができます。

左メニューには、プロジェクトエクスプローラー・検索・バージョン管理（Gitなど）・デバッグ・その他のプラグインをナビゲートするためのアイコンが表示されています。本ワークショップではこれらを使います。クリックしてそれぞれの機能を確認してください。:

image::codeready-icons.png[codeready-icons, 400, align="center"]

[NOTE]
====
表示や挙動がおかしくなったりブラウザが壊れているように見える場合には、ブラウザのタブを更新してリロードしてください。
====

OpenShift Dev Spaces ワークスペースの多くの機能には *Commands* を使ってアクセスすることができます。
ホームページには、いくつかのコマンドがリンク付きで表示されています（_New File..._、_Git Clone..._など）。
メニューにないコマンドを実行する必要がある場合は、kbd:[F1] を押してコマンドウィンドウを開くか、より伝統的な kbd:[Control+SHIFT+P] (Mac OS Xでは kbd:[Command+SHIFT+P] ) を押すことができます。

最初のプロジェクトをインポートしましょう。**Git Clone..** をクリックします。(または、kbd:[F1] をタイプし 'git' を入力し自動補完を用いて表示された _Git Clone.._ をクリックします)

image::codeready-git-clone-page.png[codeready-git-clone-page, 700, align="center"]

**Repository URL** に以下の値を入力しプロンプトを次のステップへ進みます。*Firefox* を利用している場合、最後に余分なスペースが貼り付けられてしまうことがあります。:

[source, shell, role="copypaste"]
----

https://github.com/RedHat-Middleware-Workshops/dg8-workshop-labs

----

image::codeready-git-clone-embedded.png[codeready-git-clone-embedded, 700, align="center"]

リポジトリをクローンするフォルダを選択してください。これでプロジェクトがワークスペースへインポートされました。次のスクリーンショットは、lab プロジェクトがインポートされた後のワークスペースを示しています。

1. 左メニューにプロジェクトエクスプローラーがあり、*EXPLORER > DG8-WORKSHOP-LABS* が表示されています。プロジェクトエクスプローラーはソースファイルをナビゲートするために使用できます。ソースファイルをクリックするとエディターが開きます。
2. 右メニューの `Workspace Command View` には *WORKSPACE: {{ USER_ID }}-WORKSPACE* という見出しがあります。このビューでは、ポイント＆クリックのコマンドを作成することができます。これらのコマンドは本ワークショップ全体を通して使用されます。

image::codeready-view.png[codeready-view, 700, align="center"]



== 演習問題

最初は5つの演習問題から構成されています。これらの演習では、Red Hat Data Grid の機能の一部を垣間見ることができ、アプリケーションで Data Grid を使用する方法を学ぶための良い出発点となります。以下は演習の概要です:

1. *Exercise 1* - キャッシュの作成
2. *Exercise 2* - JSR-107, JCache
3. *Exercise 3* - Functional API (オプション)
4. *Exercise 4* - Streaming data from the Cache (オプション)
5. *Exercise 5* - トランザクション管理

各演習問題には対応する `.java` ファイル（例：`Exercise1.java`）があります。このラボにおいて必要な maven プロジェクトは `dg8-exercises` です。
次のスクリーンショットは Java ファイルが配置されている場所を示しています。パッケージ名は `org.acme` である。

image::codeready-view-exercises.png[codeready-view-exercises, 700, align="center"]


すべての演習問題には `//TODO:` がついています。この `//TODO:` は、その下にコードを書く必要があることを意味しています。何が必要なのかがわかるようにコメントをつけました。指示が理解できない場合は講師に質問してください。

さらに、先の演習セクションで `//TODO` についてより詳しく、何をすべきかを説明していることがわかるでしょう。

=== Exercise 1: ローカルキャッシュの作成

初めに、Java の _Maps_ がなぜキャッシュに適しているか考えましょう。
Maps は高速であり、`hashCode` や `equals` といったメソッドを使って、Maps にデータを追加する方法を決定します。
これは、データを読み書きするのに十分な速度（O(1)）が出せるということであり、パフォーマンスにとって例外的なことでありキャッシュに期待されることでもあります。
データの保存はキーとバリューのペアで行われます。``Map`` には他にも色々ありますが、まずは基本的なキャッシュの使い方から始めましょう。

*CacheManager*  は、Cache インスタンスを取得するための主なメカニズムであり、キャッシュを使用するための出発点として利用されます。

基本的に、`Map` オブジェクトを使用する場合、`Map` を作成しすべてのキーとバリューのペアを格納します。
しかし、Red Hat Data Grid / Infinispan のようなツールを使用する場合、単純なマップ以上のもの（リスナーやイベントなど）を利用することができます。

NOTE: CacheManager は重いオブジェクトであり JVM ごとに2つ以上の *CacheManager* インスタンスを持つことは推奨されません。
（特定の構成要件で2つ以上が必要な場合を除きますが、これは最小限の有限数のインスタンスになります）

Exercise1 クラスの main メソッドに以下を追加します: 

[source, java, role="copypaste"]
----
    // TODO: Construct a simple local cache manager with a default configuration
    DefaultCacheManager cacheManager = new DefaultCacheManager();
----

これで `cacheManager` ができたので、次はキャッシュがどのようなものかを定義することができます。
システムから様々な機能を選択することができます（例えば、グループ化、ストリーム、リスナー、Eviction やクラスタリングの戦略など）。
以下の例ではデフォルトの設定を使用しています。

[source, java, role="copypaste"]
----
    // TODO: Define local cache configuration
    cacheManager.defineConfiguration("local", new ConfigurationBuilder().build());
----

キャッシュを定義したので、次は *CacheManager* からキャッシュを取得します。また、キャッシュはキーとバリューの両方を `Strings` として持つように定義しました。

[source, java, role="copypaste"]
----
    // TODO: Obtain the local cache
    Cache<String, String> cache = cacheManager.getCache("local");
----

最後にキャッシュのエントリを put してみましょう。"key" と ”value” は好きな値に変更してください。

[source, java, role="copypaste"]
----
    // TODO: Store a value
    cache.put("key", "value");
----

ここでは、キーを指定してバリューを取得しています。キーは前の行の `cache.put` で使用したものと同じにする必要があります。キャッシュにキーを指定することで、キャッシュに格納されているバリューを取得することができます。更新の場合も同じ処理です。

[source, java, role="copypaste"]
----
    // TODO: Retrieve the value and print it out
    System.out.printf("key = %s\n", cache.get("key"));
----

最後に *CacheManager* は重いオブジェクトであることから、終了したら `stop()` メソッドを呼び出してインスタンスを閉じます。

[source, java, role="copypaste"]
----
    // TODO: Stop the cache manager and release all resources
    cacheManager.stop();
----

これで本演習に必要なものは揃いました。
`Exercise1` をクリックして、ワークスペースのコマンドビューから実行することもできます。
または、`>_ New Terminal` から新しいターミナルを開き、maven コマンドを使用して手動で実行することもできます。どちらの方法でも動作します。

[Important]
====

ターミナルから直接 maven コマンドを実行する場合、exercises プロジェクトへのパスは以下のようになることを覚えておいてください： `/projects/dg8-workshop-labs/dg8-exercises`
ターミナルから maven コマンドを実行する前に、このディレクトリにいることを確認してください。

====

[source, shell, role="copypaste"]
----
mvn clean compile && \
mvn exec:java -Dexec.mainClass=org.acme.Exercise1
----

[NOTE]
====
ビルドの初回実行時は Maven の依存関係をダウンロードしてキャッシュします。次にビルドする時はもう少し速くなるでしょう。
====

以下のような出力が表示されるはずです。:
[source, shell, role="copypaste"]
----
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ dg8-exercises ---
Jan 18, 2023 7:12:36 AM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarting
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Jan 18, 2023 7:12:36 AM org.infinispan.marshall.core.impl.DelegatingUserMarshaller start
INFO: ISPN000556: Starting user marshaller 'org.infinispan.commons.marshall.ImmutableProtoStreamMarshaller'
key = value
----

コードから `key = value` と表示されているのが分かります。


=== Exercise 2: JSR-107 JCache
キャッシュという用語は一般的にデータを読みやすいようにメモリに保存するコンポーネントを指します。
キャッシュは計算が難しい値や素早くアクセスする必要のある値を保存するために使われます。
先に述べたように、単純な `java.util` パッケージは必要な機能をすべて備えておらず、自分で設定するには難しく複雑です。
Java の一時的なキャッシュ API を定義するために Java Specification Request (JSR-107) が作成されました。
この仕様では、ローカルおよび分散ユースケースの両方でデータを保存および管理するためのいくつかの標準 API が定義されています。

Red Hat Data Grid/Infinispan において JSR-107 を使用する方法を見てみましょう。`Exercise2.java` に対して指定されたコメントマーカーに以下のコードを追加します。:

[source, java, role="copypaste"]
----
        // TODO: Construct a simple local cache manager with default configuration
        CachingProvider jcacheProvider = Caching.getCachingProvider(); <1>
        CacheManager cacheManager = jcacheProvider.getCacheManager(); <2>
        MutableConfiguration<String, String> configuration = new MutableConfiguration<>(); <3>
        configuration.setTypes(String.class, String.class); <4>

        // TODO: create a cache using the supplied configuration
        Cache<String, String> cache = cacheManager.createCache("myCache", configuration); <5>
----
上のコードをもう少し細かく見てみましょう。:

<1> 標準 API の一部である `CachingProvider` を使用
<2> Caching プロバイダは `CacheManager` を提供
<3> キャッシュの設定オブジェクトの作成 (この場合は `MutableConfiguration`)
<4> キャッシュのキーとバリューの型を設定（JSR-107 API を使用しているため前回の演習とは異なります）
<5> キャッシュの取得

キャッシュのエントリを put してみましょう。"key" と ”value” は好きな値に変更してください。
[source, java, role="copypaste"]
----
        // Store and retrieve value
        cache.put("key", "value");
        System.out.printf("key = %s\n", cache.get("key"));
----

`CacheManager` を使用しない場合はクローズしてください。:
[source, java, role="copypaste"]
----
        // TODO: Stop the cache manager and release all resources
        cacheManager.close();
----

OpenShift Dev Spaces ターミナルにて次のコマンドを実行するか、右側のワークスペースメニューから `Exercise2` コマンドを実行してください。
[source, shell, role="copypaste"]
----
mvn clean compile && \
mvn exec:java -Dexec.mainClass=org.acme.Exercise2
----

以下のような出力が表示されるはずです。最後の行にキーとバリューが表示されています。
[source, shell, role="copypaste"]
----
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ dg8-exercises ---
Jan 18, 2023 7:14:19 AM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarting
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Jan 18, 2023 7:14:19 AM org.infinispan.marshall.core.impl.DelegatingUserMarshaller start
INFO: ISPN000556: Starting user marshaller 'org.infinispan.commons.marshall.ImmutableProtoStreamMarshaller'
key = value
----

=== Exercise 3: Functional API
The approach taken by the Functional Map API when working with multiple keys is to provide a lazy, pull-style API. All multi-key operations take a collection parameter that indicates the keys to work with (and sometimes contains 'value' information too), and a function to execute for each key/value pair. Each function's ability depends on the entry view received as a function parameter, which changes depending on the underlying map: 

* `ReadEntryView` for `ReadOnlyMap`.
* `WriteEntryView` for `WriteOnlyMap`.
* `ReadWriteView` for `ReadWriteMap`. 

The return type for all multi-key operations, except the ones from `WriteOnlyMap`, is an instance of `Traversable`, which exposes methods to work with the returned data from each function execution. Let's see an example.

This example demonstrates some of the key aspects of working with multiple entries using the Functional Map API. All data-handling methods (including multi-key methods) for `WriteOnlyMap` return `CompletableFuture<Void>`, because there's nothing the function could provide that could not be computed in advance or outside the function.

There is a particular type of multi-key operation that works on all keys/entries stored in Infinispan. The behavior is very similar to the multi-key operations shown above, with the exception that they do not take a collection of keys (or values) as parameters.

There are a few interesting things to note about working with all entries using the Functional Map API:

* When working with all entries, the order of the `Traversable` is not guaranteed.
* Read-only's `keys()` and `entries()` offer the possibility to traverse all keys and entries present in the cache.
* When traversing entries, both keys and values, including metadata, are available:
** Contrary to Java's `ConcurrentMap`, there's no possibility to navigate only the values (and metadata) since there's little to be gained from such a method.
** Once a key's entry is retrieved, there's no extra cost to provide the key as well.


Let us start by initializing our cache with the `DefaultCacheManager` as in the previous labs. However, now we use the functional API, and hence after getting the cache, our `Map` implementation is different.

==== How to use the Functional API?

Using an Asynchronous API, all methods with a single result return a `CompletableFuture` wrapping the result itself. To avoid blocking, it offers the possibility to receive callbacks when the `CompletableFuture` is completed, or it can be chained or composed with other `CompletableFuture` instances. Let's get started with Exercise3.java.

[NOTE]
====
For the sake of simplicity, you do not need to write part of the snippet. Please remove the following lines in the main method:

      /* UNCOMMENT When starting this exercise
      UNCOMMENT When starting this exercise */


====

The previous note uncomments the following code:

[source, java, role="copypaste"]
----
        DefaultCacheManager cacheManager = new DefaultCacheManager();
        cacheManager.defineConfiguration("local", new ConfigurationBuilder().build());
        AdvancedCache<String, String> cache = cacheManager.<String, String>getCache("local").getAdvancedCache();
        FunctionalMapImpl<String, String> functionalMap = FunctionalMapImpl.create(cache);
        FunctionalMap.WriteOnlyMap<String, String> writeOnlyMap = WriteOnlyMapImpl.create(functionalMap);<1>
        FunctionalMap.ReadOnlyMap<String, String> readOnlyMap = ReadOnlyMapImpl.create(functionalMap);
----


First, We want to asynchronously write to this cache. Copy and paste the following snippet to Exercise3.java:

[source, java, role="copypaste"]
----
        // TODO Execute two parallel write-only operation to store key/value pairs
        CompletableFuture<Void> writeFuture1 = writeOnlyMap.eval("key1", "value1",
                (v, writeView) -> writeView.set(v));
        CompletableFuture<Void> writeFuture2 = writeOnlyMap.eval("key2", "value2",
                (v, writeView) -> writeView.set(v));
----

Write-only operations require locks to be acquired. They do not require reading previous value or metadata parameter information associated with the cached entry, which can be expensive since they involve talking to a remote node in the cluster or the persistence layer. Exposing write-only operations makes it easy to take advantage of this vital optimization.



Second, let's do the same using read operations:

[source, java, role="copypaste"]
----
        //TODO When each write-only operation completes, execute a read-only operation to retrieve the value
        CompletableFuture<String> readFuture1 =
                writeFuture1.thenCompose(r -> readOnlyMap.eval("key1", EntryView.ReadEntryView::get));
        CompletableFuture<String> readFuture2 =
                writeFuture2.thenCompose(r -> readOnlyMap.eval("key2", EntryView.ReadEntryView::get));
----

This code snippet exposes read-only operations that can be executed against the functional map. The information can be read per entry in the functional map. Read-only operations have the advantage that no locks are acquired for the duration of the operation.

Third, let's print the operation as it completes.

[source, java, role="copypaste"]
----
        //TODO When the read-only operation completes, print it out
        System.out.printf("Created entries: %n");
        CompletableFuture<Void> end = readFuture1.thenAcceptBoth(readFuture2, (v1, v2) -> System.out.printf("key1 = %s%nkey2 = %s%n", v1, v2));

        // Wait for this read/write combination to finish
        end.get();
----

Now that we have seen how a `WriteOnly` and `ReadOnly` `Map` works, let's also add the `ReadWriteMap`. Read-write operations offer the possibility of writing values or metadata parameters and returning previously stored information. Read-write operations are also crucial for implementing conditional, compare-and-swap (CAS) operations. Locks need to be acquired before executing the read-write lambda.

[source, java, role="copypaste"]
----
        // Use read-write multi-key based operation to write new values
        // together with lifespan and return previous values
        Map<String, String> data = new HashMap<>();
        data.put("key1", "newValue1");
        data.put("key2", "newValue2");
        Traversable<String> previousValues = readWriteMap.evalMany(data, (v, readWriteView) -> {
            String prev = readWriteView.find().orElse(null);
            readWriteView.set(v, new MetaLifespan(Duration.ofHours(1).toMillis()));
            return prev;
        });
----

Now let's run our code and see how it works. Run the above exercise as follows in the CodeReady terminal, or you can also choose to execute the command `Exercise3` in your Workspace Menu on the right.

[source, shell, role="copypaste"]
----
mvn clean compile && \
mvn exec:java -Dexec.mainClass=org.acme.Exercise3
----

You should be able to see an output similar to the following:
[source, shell, role="copypaste"]
----
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ dg8-exercises ---
Jan 18, 2023 7:14:45 AM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarting
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Jan 18, 2023 7:14:45 AM org.infinispan.marshall.core.impl.DelegatingUserMarshaller start
INFO: ISPN000556: Starting user marshaller 'org.infinispan.commons.marshall.ImmutableProtoStreamMarshaller'
Created entries: 
key1 = value1
key2 = value2
Updated entries: 
ReadOnlySnapshotView{key=key1, value=newValue1, metadata=MetaParamsInternalMetadata{params=MetaParams{length=1, metas=[MetaLifespan=3600000]}}}
ReadOnlySnapshotView{key=key2, value=newValue2, metadata=MetaParamsInternalMetadata{params=MetaParams{length=1, metas=[MetaLifespan=3600000]}}}
Previous entry values: 
value1
value2
----

=== Exercise 4: Streaming data from the cache

Infinispan Distributed Java Streams can be used to calculate analytics over existing data. Through the overloading of methods, Infinispan can offer a simple way of passing lambdas that are `Serializable` without the need for explicit casting. Being able to produce binary formats for the lambdas is an essential step for Java Streams executions to be distributed.

[NOTE]
====
Please remove the following lines in the main method.

      /* UNCOMMENT When starting this exercise
      UNCOMMENT When starting this exercise */
====

Use the following code to create a lambda to write data into our cache:

[source, java, role="copypaste"]
----
        // TODO: Store some values
        int range = 10;
        IntStream.range(0, range)
                .boxed()
                .forEach(i -> cache.put(i + "-key", i + "-value"));
----

And now we read that data summing up the values:

[source, java, role="copypaste"]
----
        // TODO: Map and reduce the keys
        int result = cache.keySet().stream()
                .map(e -> Integer.valueOf(e.substring(0, e.indexOf("-"))))
                .collect(() -> Collectors.summingInt(Integer::intValue));
----

Let's run our code and see how it works. Run the above exercise as follows in the CodeReady terminal, or you can also choose to execute the command `Exercise4` in your Workspace Menu on the right.

[source, shell, role="copypaste"]
----
mvn clean compile && \
mvn exec:java -Dexec.mainClass=org.acme.Exercise4
----

You should be able to see an output similar to the following. On the last line, you can see the result of the MapReduce operation:
[source, shell, role="copypaste"]
----
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ dg8-exercises ---
Jan 18, 2023 7:15:09 AM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarting
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Jan 18, 2023 7:15:09 AM org.infinispan.marshall.core.impl.DelegatingUserMarshaller start
INFO: ISPN000556: Starting user marshaller 'org.infinispan.commons.marshall.ImmutableProtoStreamMarshaller'
Result = 45
----

=== Exercise 5: トランザクション管理

トランザクションはどのようなビジネスアプリケーションにおいても必要不可欠です。
通常、トランザクションはデータセットと一緒に使われ、データベースに関連することが多いです。
分散されたデータセットがある場合、ビジネスロジックにトランザクションが必要です。
Infinispan はトランザクションをサポートしています。
クラスタに新しいノードが追加されたり、他のノードによってエントリが書き込まれたりするシナリオが考えられます。
Infinispanのトランザクションマネージャはそのようなイベントを認識し処理します。
トランザクションの設計については、 https://github.com/infinispan/infinispan-designs[Infinispan Designs repository] を参照してください。

[NOTE]
====
main メソッドから以下の行を削除してください。

      /* UNCOMMENT When starting this exercise
      UNCOMMENT When starting this exercise */
====

キャッシュから TransactionManager を取得しましょう。:
[source, java, role="copypaste"]
----
        //TODO Obtain the transaction manager
        TransactionManager transactionManager = cache.getAdvancedCache().getTransactionManager();
----

トランザクションを開始し、2つのエントリを書き込み、コミットします。

[source, java, role="copypaste"]
----
        // TODO Perform some operations within a transaction and commit it
        transactionManager.begin();
        cache.put("key1", "value1");
        cache.put("key2", "value2");
        transactionManager.commit();
----

ロールバックのシナリオも考えましょう。エントリを書き込み、ロールバックします。

[source, java, role="copypaste"]
----
        //TODO Perform some operations within a transaction and roll it back
        transactionManager.begin();
        cache.put("key1", "value3");
        cache.put("key2", "value4");
        transactionManager.rollback();
----

コードを実行し、どのように機能するか見てみましょう。

OpenShift Dev Spaces ターミナルにて次のコマンドを実行するか、右側のワークスペースメニューから `Exercise5` コマンドを実行してください。

[source, shell, role="copypaste"]
----
mvn clean compile && \
mvn exec:java -Dexec.mainClass=org.acme.Exercise5
----

以下のような出力が表示されるはずです。:
[source, shell, role="copypaste"]
----
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ dg8-exercises ---
Jan 18, 2023 7:15:24 AM org.infinispan.lock.impl.ClusteredLockModuleLifecycle cacheManagerStarting
INFO: ISPN029009: Configuration is not clustered, clustered locks are disabled
Jan 18, 2023 7:15:25 AM org.infinispan.marshall.core.impl.DelegatingUserMarshaller start
INFO: ISPN000556: Starting user marshaller 'org.infinispan.commons.marshall.ImmutableProtoStreamMarshaller'
Jan 18, 2023 7:15:25 AM org.jboss.threads.Version <clinit>
INFO: JBoss Threads version 2.3.3.Final-redhat-00001
Jan 18, 2023 7:15:25 AM org.infinispan.transaction.lookup.GenericTransactionManagerLookup useDummyTM
INFO: ISPN000104: Using EmbeddedTransactionManager
key1 = value1
key2 = value2
key1 = value1
key2 = value2
----

このように、新しい値を書き込んだにもかかわらず、ロールバックすると値はトランザクションの初期値に書き換えられます。

==== Congratulations!

これで Red Hat Data Grid の基本機能のセクションは完了です。次のセクションへ進み、より詳細な例を体験しましょう。
